
---
title: "GeneSet: Representing Gene Sets in the Tidyverse"
author: "Kayla Morrell"
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document
package: GeneSet
vignette: >
    %\VignetteIndexEntry{GeneSet: Representing Gene Sets in the Tidyverse}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEndcoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Introduction
`GeneSet` is a package that represents gene sets in a tibble format with the `GeneSet` class. Gene sets are read in and converted into a tibble format. From here, typical `dplyr` operations can be performed on the tibble gene set.

# Installation
Install the most recent version from Bioconductor:

```{r bioconductor, eval = FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("GeneSet")
```

The development version is also available for install from GitHub:

```{r github, eval = FALSE}
BiocManager::install("Kayla-Morrell/GeneSet")
```

Then load `GeneSet`:

```{r  load, message = FALSE}
library(GeneSet)
```
# GeneSet

## Input and Output

`GeneSet` can create a `GeneSet` using two different input methods. The first is to input named character vectors of gene sets. `GeneSet` returns three tibbles, `gene` which contains the genes, `set` which contains the sets and `geneset` which contains genes and sets. 

```{r constructor}
tbl <- GeneSet(set1 = letters, set2 = LETTERS)
tbl
```

The second method of creating a `GeneSet` would be to read in `.gmt` files. Using `import()`, a path to a downloaded `.gmt` file is read in and a `GeneSet` is returned. The example below uses a hallmark gene set downloaded from [GSEA][], which is also included with this package. This `GeneSet` includes a `source` column within the `geneset` tibble for reference as to where the gene set came from.

[GSEA]: http://software.broadinstitute.org/gsea/index.jsp

```{r gmt}
gmtFile <- system.file(package = "GeneSet",
                        "extdata",
                        "hallmark.gene.symbol.gmt")
tbl2 <- import(gmtFile)
tbl2
```

`export()` allows for a `GeneSet` to be exported into a temporary file with the extention `.gmt`.

```{r export, tidy = TRUE}
fl <- tempfile(fileext = ".gmt")
gmt <- export(tbl2, fl)
gmt
```

## Implemented functions

`GeneSet` adopts the use of many `dplyr` functions such as `filter()`, `select()`, `mutate()`, `summarise()`, `arrange()`, and `tbl_vars()`.

```{r examples}
tbl <- GeneSet(set1 = letters, set2 = LETTERS)
tbl
tbl %>% filter(gene == "a" | gene == "A")
tbl %>% mutate(pval = rnorm(1:52))
tbl %>% group_by(set,gene) %>% group_vars()
```

Another feature available to `GeneSet` is the ability to activate different tibbles. When a `GeneSet` is created, the tibble `geneset` is automatically activated and all functions will be performed on this tibble. With `gs_activate()` the user is able to pick a different tibble to activate and work on.

```{r activate}
tbl <- GeneSet(set1 = letters, set2 = LETTERS)
tbl
tbl %>% gs_activate(gene) %>% filter(gene == "a" | gene == "A")
tbl %>% gs_activate(set) %>% mutate(pval = rnorm(1:2))
tbl %>% gs_activate(gene) %>% summarise(n = n())
```

# Case study

Next, we demonstrate the use of `GeneSet` with an experiement dataset `airway` from the package `airway`. This data is from an RNA-Seq experiment on airway smooth muscle (ASM) cell lines.

The first step is to load the library and the necessary data.

```{r airway, message = FALSE}
library(airway)
data("airway")
se <- airway
```

This function `go_sets()` discovers the keys from the org object and uses `AnnotationDbi::select` to create a mapping of Ensembl ids and GO ids. We represent these identifieres as a GeneSet.

```{r go_sets, message = FALSE}
library(org.Hs.eg.db)
go_sets <- 
    function(org = org.Hs.eg.db)
{
    map <- AnnotationDbi::select(
        org, keys(org, "ENSEMBL"), c("ENSEMBL", "GO"), "ENSEMBL"
    )
    do.call(GeneSet, split(map$ENSEMBL, map$GO))
}
```

Using our `go_sets` function we are able to map the Ensembl ids and GO ids from the genome wide annotation for Human data in the `org.Hs.eg.db` package. The Ensembl ids are treated as genes while the GO ids are treated as sets.

```{r go}
go <- go_sets(org.Hs.eg.db)
```

Some users may not be interested in reporting the non-descriptive genes. We demonstrate subsetting the `airway` data to include non-zero assays and then filtering out the non-descriptive genes.

```{r drop_assays}
se1 = se[rowSums(assay(se)) != 0,]
gs_activate(go, gene) %>% filter(gene %in% rownames(se1))
```

It may also be of interest to users to know how many genes are in each set. Using the `count` function we are able to calculate the genes per set.

```{r count}
gs_activate(go, geneset) %>% group_by(set) %>% dplyr::count()
```

It may also be helpful to remove sets that are empty. Since we have shown how to calculate the number of genes per set, we know that this data set does not contain any empty sets. We decide to demonstrate regardless for those users that may need this functionality.

```{r empty}
drop <- gs_activate(go, geneset) %>% group_by(set) %>%
     dplyr::count() %>% filter(n == 0) %>% pull(set)
gs_activate(go, set) %>% filter(!(set %in% drop))
```

Another mapping example is created using the `mapIds` function. A tibble of Ensembl ids and gene symbols made and then we use our `map_gene` function to map the Ensembl id genes in `go` to gene symbols.

```{r more_mapping}
map <- mapIds(
    org.Hs.eg.db, keys(org.Hs.eg.db, "ENSEMBL"), "SYMBOL", "ENSEMBL"
)
tbl <- tibble::enframe(map, name = "ENSEMBL", value="SYMBOL")
go %>% map_gene(tbl$ENSEMBL, tbl$SYMBOL)

## gs_map_org(org.Hs.eg.db, "ENSEMBL", "SYMBOL")
```

Another functionality to demonstrate would be adding in information to the tibbles. Using the `GO.db` library we are able to map definitions to the GO ids. From there we use the mutate function to add a defintion column to the set tibble.

```{r, message = FALSE}
library(GO.db)
map <- mapIds(GO.db, as.character(gs_set(go)$set), "DEFINITION", "GOID")
gs_activate(go, "set") %>% mutate(definition = unname(map))
```

The library `KEGGREST` is a client interface to the KEGG REST server. KEGG contains pathway maps that represent interaction, reaction and relation networks for various biological processes and diseases. We create a function that uses `KEGGREST` that develops a GeneSet that contains the genes for every pathway map in KEGG.

<!-- need to work on the sapply function, currently taking almost 3 minutes to run the keggGet for all 330 pathways. -->

<!-- need to figure out how to change set back to a factor, after left_join -->


```{r kegg, message = FALSE}
library(KEGGREST)

kegg_sets <- function(species = "hsa") {
    paths <- tibble::enframe(keggList("pathway", "hsa"))
    paths <- mutate(
        paths,
        name = sub("path:", "", name),
        value = gsub(" \\-.*", "", value)
    )
    genes <- lapply(paths$name, function(x) {
        path <- keggGet(x) # (n = 330) will take some time
        path[[1]]$GENE[c(TRUE, FALSE)]
    })
    names(genes) <- paths$name
    genes <- genes[lengths(genes) != 0]

    do.call(GeneSet, genes)
}
```

Due to limiations of the KEGGREST package, `keggGet` can only retrieve 10 entries at a time. There for the `lapply` function above would take some time to run on it's own. There for we have decided to use `BiocFileCache` to make the data available to the user.

```{r file_cache, message = FALSE}
library(BiocFileCache)
rname <- "kegg_hsa"
exists <- NROW(bfcquery(query=rname, field="rname")) != 0L
if (!exists)
{
    fl <- bfcnew(rname = rname, ext = ".gmt")
    export(kegg_sets("hsa"), fl)
}
kegg <- import(bfcrpath(rname=rname))
```

When creating the KEGG pathway GeneSet we removed pathways that did not contain any genes. Since we want to add in the pathway names to our GeneSet we must first filter out the pathways that were removed. Then we can left join the pathways with the set tibble. We then mutate the gene tibble to contain both Ensembl and Entrez ids. 

```{r kegg_filter, eval = FALSE}
paths <- filter(kegg, name %in% gs_geneset(tbl)$set)
gs_set(tbl) <- gs_set(tbl) %>% left_join(paths, by = c("set" = "name"))
tbl <- gs_activate(tbl, gene) %>% 
    mutate(
        ensembl = mapIds(
            org.Hs.eg.db,
            keys = gs_gene(tbl)$gene,
            column = "ENSEMBL",
            keytype = "ENTREZID",
            multivals = "first"
        )
    )
```
Since we are working with ASM data we thought we would subset the `airway` data to contain only the genes in the asthma pathway. This filter can be done on either the KEGG id (which for asthma is "hsa05310") or the pathway name. We demonstrate using the pathway name.

```{r subset, eval = FALSE}
asthma <- tbl %>% gs_activate(set) %>% filter(value == "Asthma")

se <- se[rownames(se) %in% gs_gene(asthma)$ensembl,]

se
rowData(se)
```

The filtering can also be done for multiple pathways. 

```{r multiple, eval = FALSE}
pathways <- c("hsa05310", "hsa04110", "hsa05224", "hsa04970")
multipaths <- tbl %>% gs_activate(set) %>% filter(set %in% pathways)

multipaths
```

# Session info

```{r}
sessionInfo()
```
