---
title: "BiocSet: Representing Element Sets in the Tidyverse"
author: 
- name: Kayla Morrell
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
- name: Martin Morgan
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
package: BiocSet
vignette: >
  %\VignetteIndexEntry{BiocSet: Representing Element Sets in the Tidyverse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEndcoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Introduction
`BiocSet` is a package that represents element sets in a tibble format with the `BiocSet` class. Element sets are read in and converted into a tibble format. From here, typical `dplyr` operations can be performed on the tibble element set. `BiocSet` also provides functionality for mapping different ID types and being directed to a reference webpage for specific elements/sets.

# Installation
Install the most recent version from Bioconductor:

```{r bioconductor, eval = FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("BiocSet")
```

The development version is also available for install from GitHub:

```{r github, eval = FALSE}
BiocManager::install("Kayla-Morrell/BiocSet")
```

Then load `BiocSet`:

```{r  load, message = FALSE}
library(BiocSet)
```
# BiocSet

## Input and Output

`BiocSet` can create an `BiocSet` using two different input methods. The first is to input named character vectors of element sets. `BiocSet` returns three tibbles, `element` which contains the elements, `set` which contains the sets and `elementset` which contains elements and sets. 

```{r constructor}
tbl <- BiocSet(set1 = letters, set2 = LETTERS)
tbl
```

The second method of creating an `BiocSet` would be to read in `.gmt` files. Using `import()`, a path to a downloaded `.gmt` file is read in and an `BiocSet` is returned. The example below uses a hallmark element set downloaded from [GSEA][], which is also included with this package. This `BiocSet` includes a `source` column within the `elementset` tibble for reference as to where the element set came from.

[GSEA]: http://software.broadinstitute.org/esea/index.jsp

```{r gmt}
gmtFile <- system.file(package = "BiocSet",
                        "extdata",
                        "hallmark.gene.symbol.gmt")
tbl2 <- import(gmtFile)
tbl2
```

`export()` allows for an  `BiocSet` to be exported into a temporary file with the extention `.gmt`.

```{r export, tidy = TRUE}
fl <- tempfile(fileext = ".gmt")
gmt <- export(tbl2, fl)
gmt
```

## Implemented functions

`BiocSet` adopts the use of many `dplyr` functions such as `filter()`, `select()`, `mutate()`, `summarise()`, `arrange()`, and `tbl_vars()`.

```{r examples}
tbl <- BiocSet(set1 = letters, set2 = LETTERS)
tbl
tbl %>% filter(element == "a" | element == "A")
tbl %>% mutate(pval = rnorm(1:52))
```

Another feature available to `BiocSet` is the ability to activate different tibbles. When a `BiocSet` is created, the tibble `elementset` is automatically activated and all functions will be performed on this tibble. With each of the functions the user is able to pick a different tibble to activate and work on by using 'verb_tibble'. After the function is executed than the 'active' tibble is returned back to the tibble that was active before the function call. Some examples are shown below of how these functions work.

```{r activate}
tbl <- BiocSet(set1 = letters, set2 = LETTERS)
tbl
tbl %>% filter_element(element == "a" | element == "A")
tbl %>% mutate_set(pval = rnorm(1:2))
tbl %>% arrange_elementset(desc(element))
```

# Case study

Next, we demonstrate the use of `BiocSet` with an experiement dataset `airway` from the package `airway`. This data is from an RNA-Seq experiment on airway smooth muscle (ASM) cell lines.

The first step is to load the library and the necessary data.

```{r airway, message = FALSE}
library(airway)
data("airway")
se <- airway
```

This function `go_sets()` discovers the keys from the org object and uses `AnnotationDbi::select` to create a mapping to GO ids. We represent these identifieres as a BiocSet. Using our `go_sets` function we are able to map the Ensembl ids and GO ids from the genome wide annotation for Human data in the `org.Hs.eg.db` package. The Ensembl ids are treated as elements while the GO ids are treated as sets.

```{r go_sets, message = FALSE}
library(org.Hs.eg.db)
go <- go_sets(org.Hs.eg.db, "ENSEMBL")
go
```

Some users may not be interested in reporting the non-descriptive elements. We demonstrate subsetting the `airway` data to include non-zero assays and then filtering out the non-descriptive elements.

```{r drop_assays}
se1 = se[rowSums(assay(se)) != 0,]
go %>% filter_element(element %in% rownames(se1))
```

It may also be of interest to users to know how many elements are in each set. Using the `count` function we are able to calculate the elements per set.

```{r count}
go %>% group_by(set) %>% dplyr::count()
```

It may also be helpful to remove sets that are empty. Since we have shown how to calculate the number of elements per set, we know that this data set does not contain any empty sets. We decide to demonstrate regardless for those users that may need this functionality.

```{r empty}
drop <- es_activate(go, elementset) %>% group_by(set) %>%
    dplyr::count() %>% filter(n == 0) %>% pull(set)
go %>% filter_set(!(set %in% drop))
```

To simplify mapping we created a function called `es_map`. This takes four arguements, a `BiocSet` object, an `AnnotationDbi` object, the id to map from, and the ide to map to. The function then performs the mapping using `mapIds` from `AnnotationDbi` and returns a `BiocSet` object. In the example below we show how to use this function to map the Ensembl ids from `go` to gene symbols.

```{r es_map}
go %>% es_map(org.Hs.eg.db, "ENSEMBL", "SYMBOL")
```

Another functionality of `BiocSet` is the ability to add information to the tibbles. Using the `GO.db` library we are able to map definitions to the GO ids. From there we use the mutate function to add a defintion column to the set tibble.

```{r adding, message = FALSE}
library(GO.db)
map <- mapIds(GO.db, as.character(es_set(go)$set), "DEFINITION", "GOID")
go %>% mutate_set(definition = unname(map))
```

The library `KEGGREST` is a client interface to the KEGG REST server. KEGG contains pathway maps that represent interaction, reaction and relation networks for various biological processes and diseases. `BiocSet` has a function that utilizes `KEGGREST` to develop a BiocSet that contains the elements for every pathway map in KEGG.

```{r kegg_sets, message = FALSE}
kegg_sets("hsa")
```

Due to limiations of the KEGGREST package, `kegg_sets` can take some time to run depending on the amount of pathways for the species of interest. Therefore we demonstrate using `BiocFileCache` to make the data available to the user.

```{r file_cache, message = FALSE}
library(BiocFileCache)
rname <- "kegg_hsa"
exists <- NROW(bfcquery(query=rname, field="rname")) != 0L
if (!exists)
{
    fl <- bfcnew(rname = rname, ext = ".gmt")
    export(kegg_sets("hsa"), fl)
}
kegg <- import(bfcrpath(rname=rname))
```

Within the `kegg_sets()` function we remove pathways that do not contain any elements. Since we want to add in the pathway names to our BiocSet we must first filter out the pathways that were removed. Then we can left join the pathways with the set tibble. We then mutate the element tibble to contain both Ensembl and Entrez ids. 

```{r kegg_filter}
#paths <- filter(kegg, name %in% es_elementset(tbl)$set)
#es_set(tbl) <- es_set(tbl) %>% left_join(paths, by = c("set" = "name"))
kegg <- kegg %>% mutate_element(
            ensembl = mapIds(
                org.Hs.eg.db,
                keys = es_element(kegg)$element,
                column = "ENSEMBL",
                keytype = "ENTREZID",
                multivals = "first"
            )
        )
```
Since we are working with ASM data we thought we would subset the `airway` data to contain only the elements in the asthma pathway. This filter can be done on either the KEGG id (which for asthma is "hsa05310") or the pathway name. We demonstrate using the pathway name.

```{r subset}
asthma <- kegg %>% filter_set(set == "hsa05310")

se <- se[rownames(se) %in% es_element(asthma)$ensembl,]

se
```

The filtering can also be done for multiple pathways. 

```{r multiple}
pathways <- c("hsa05310", "hsa04110", "hsa05224", "hsa04970")
multipaths <- kegg %>% filter_set(set %in% pathways)

multipaths
```

# Session info

```{r}
sessionInfo()
```
